"""
Video analysis module for Cricket Analysis System.
Handles Sports2D integration and video processing.
"""

import cv2
import pandas as pd
from pathlib import Path
from typing import Optional, Tuple, Dict, Any, List
from Sports2D import Sports2D

from .data_models import VideoInfo, AnalysisResult, AnalysisConfig


class VideoAnalyzer:
    """Handles video analysis using Sports2D pose estimation."""

    def __init__(self, config: AnalysisConfig, output_dir: str = "analysis_output"):
        """
        Initialize the video analyzer.

        Args:
            config: Analysis configuration
            output_dir: Output directory for analysis results
        """
        self.config = config
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)

    def analyze_video(self, video_path: str, video_name: Optional[str] = None) -> AnalysisResult:
        """
        Analyze a single video using Sports2D.

        Args:
            video_path: Path to the video file
            video_name: Optional custom name for the video

        Returns:
            AnalysisResult object containing analysis results
        """
        if video_name is None:
            video_name = Path(video_path).stem

        result_dir = self.output_dir / video_name
        result_dir.mkdir(exist_ok=True)

        # Generate Sports2D configuration
        sports2d_config = self.config.to_sports2d_config(
            video_path, result_dir)

        # Run Sports2D analysis
        Sports2D.process(sports2d_config)

        # Locate generated files
        sports2d_dir = result_dir / f"{video_name}_Sports2D"
        analyzed_video_path = sports2d_dir / f"{video_name}_Sports2D.mp4"
        angles_file = self._find_angles_file(sports2d_dir, video_name)

        return AnalysisResult(
            video_name=video_name,
            original_path=video_path,
            analyzed_path=str(analyzed_video_path),
            angles_file=str(angles_file),
            result_dir=str(result_dir)
        )

    def analyze_multiple_videos(self, video_paths: List[str]) -> Dict[str, AnalysisResult]:
        """
        Analyze multiple videos sequentially.

        Args:
            video_paths: List of video file paths

        Returns:
            Dictionary mapping video names to AnalysisResult objects
        """
        results = {}

        for video_path in video_paths:
            video_name = Path(video_path).stem
            try:
                result = self.analyze_video(video_path, video_name)
                results[video_name] = result
                print(f"Successfully analyzed: {video_name}")
            except Exception as e:
                print(f"Failed to analyze {video_name}: {e}")
                # Create a minimal result object for failed analysis
                results[video_name] = AnalysisResult(
                    video_name=video_name,
                    original_path=video_path,
                    analyzed_path="",
                    angles_file="",
                    result_dir=""
                )

        return results

    def _find_angles_file(self, sports2d_dir: Path, video_name: str) -> Path:
        """
        Find the angles file generated by Sports2D.

        Args:
            sports2d_dir: Directory containing Sports2D results
            video_name: Name of the video

        Returns:
            Path to the angles file
        """
        # Possible angle file patterns
        possible_patterns = [
            f"{video_name}_Sports2D_angles_person00.mot",
            f"{video_name}_angles_person00.mot",
            f"{video_name}_Sports2D_angles.mot",
            f"{video_name}_angles.mot"
        ]

        # Try each pattern
        for pattern in possible_patterns:
            angles_file = sports2d_dir / pattern
            if angles_file.exists():
                return angles_file

        # Look for any .mot file in the directory
        if sports2d_dir.exists():
            mot_files = list(sports2d_dir.glob('*.mot'))
            if mot_files:
                return mot_files[0]

        # Return expected path as fallback
        return sports2d_dir / f"{video_name}_Sports2D_angles_person00.mot"

    def get_video_info(self, video_path: str) -> VideoInfo:
        """
        Get information about a video file.

        Args:
            video_path: Path to the video file

        Returns:
            VideoInfo object with video metadata
        """
        return VideoInfo.from_video_path(video_path)

    def get_frame_at_index(self, video_path: str, frame_index: int) -> Optional[any]:
        """
        Extract a specific frame from a video.

        Args:
            video_path: Path to the video file
            frame_index: Index of the frame to extract

        Returns:
            Frame as numpy array or None if failed
        """
        try:
            cap = cv2.VideoCapture(video_path)
            cap.set(cv2.CAP_PROP_POS_FRAMES, frame_index)
            ret, frame = cap.read()
            cap.release()
            return frame if ret else None
        except Exception as e:
            print(
                f"Error extracting frame {frame_index} from {video_path}: {e}")
            return None

    def get_all_frames(self, video_path: str) -> Tuple[List[any], int]:
        """
        Extract all frames from a video.

        Args:
            video_path: Path to the video file

        Returns:
            Tuple of (frames_list, frame_count)
        """
        try:
            cap = cv2.VideoCapture(video_path)
            frames = []
            frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

            for i in range(frame_count):
                ret, frame = cap.read()
                if ret:
                    frames.append(frame)
                else:
                    break

            cap.release()
            return frames, len(frames)
        except Exception as e:
            print(f"Error extracting frames from {video_path}: {e}")
            return [], 0


class AnglesDataProcessor:
    """Processes angle data from Sports2D output files."""

    @staticmethod
    def read_angles_file(angles_file_path: str) -> pd.DataFrame:
        """
        Read and parse a Sports2D angles file (.mot format).

        Args:
            angles_file_path: Path to the angles file

        Returns:
            DataFrame containing angle data
        """
        angles_path = Path(angles_file_path)

        if not angles_path.exists():
            # Try to find alternative files
            result_dir = angles_path.parent
            video_name = angles_path.stem.replace(
                '_Sports2D_angles_person00', '')

            # Look for any .mot files
            mot_files = list(result_dir.glob('*.mot'))
            if mot_files:
                angles_path = mot_files[0]
            else:
                # Try alternative patterns
                alt_patterns = [
                    f"{video_name}_angles_person00.mot",
                    f"{video_name}_Sports2D_angles.mot",
                    f"{video_name}_angles.mot"
                ]

                for pattern in alt_patterns:
                    alt_path = result_dir / pattern
                    if alt_path.exists():
                        angles_path = alt_path
                        break
                else:
                    return pd.DataFrame()

        try:
            return AnglesDataProcessor._parse_mot_file(angles_path)
        except Exception as e:
            print(f"Error reading angles file {angles_path}: {e}")
            return pd.DataFrame()

    @staticmethod
    def _parse_mot_file(file_path: Path) -> pd.DataFrame:
        """
        Parse a .mot file format used by Sports2D.

        Args:
            file_path: Path to the .mot file

        Returns:
            DataFrame with parsed angle data
        """
        with open(file_path, 'r') as f:
            lines = f.readlines()

        # Find data start after 'endheader'
        data_start = None
        for i, line in enumerate(lines):
            if line.strip().startswith('endheader'):
                data_start = i + 1
                break

        if data_start is None:
            raise ValueError("Could not find 'endheader' marker in .mot file")

        # Parse header and data
        header_line = lines[data_start].strip()
        columns = header_line.split('\t')

        # Parse data lines
        data_start += 1
        data = []
        for line in lines[data_start:]:
            if line.strip():
                data.append(line.strip().split('\t'))

        df = pd.DataFrame(data, columns=columns)

        # Convert numeric columns
        numeric_columns = df.columns[1:]  # Skip first column (usually time)
        df[numeric_columns] = df[numeric_columns].apply(
            pd.to_numeric, errors='coerce')

        return df

    @staticmethod
    def extract_frame_data(angles_df: pd.DataFrame, frame_index: int) -> Dict[str, float]:
        """
        Extract angle data for a specific frame.

        Args:
            angles_df: DataFrame containing angle data
            frame_index: Index of the frame

        Returns:
            Dictionary of angle measurements
        """
        if angles_df.empty or frame_index >= len(angles_df):
            return {}

        frame_data = angles_df.iloc[frame_index].to_dict()

        # Convert to float and handle NaN values
        cleaned_data = {}
        for key, value in frame_data.items():
            try:
                if pd.isna(value):
                    cleaned_data[key] = 0.0
                else:
                    cleaned_data[key] = float(value)
            except (ValueError, TypeError):
                cleaned_data[key] = 0.0

        return cleaned_data
